"""
Patch for database.py to support Postgres in production
Import this BEFORE importing database module

IMPORTANT: For Vercel + Supabase deployments:
- Use DATABASE_URL (connection pooler, port 6543) for best compatibility
- The pooler is IPv4 compatible and designed for serverless environments
- If using direct connection (port 5432), it may fail with IPv6 issues on Vercel
"""
import os
import sys
from urllib.parse import urlparse, unquote

# Check if we're in production (Vercel)
# Prefer DATABASE_URL (pooler) over POSTGRES_URL_NON_POOLING (direct connection)
DATABASE_URL = os.getenv('DATABASE_URL') or os.getenv('POSTGRES_URL')
IS_POSTGRES = DATABASE_URL and 'postgres' in DATABASE_URL

if IS_POSTGRES:
    # We're in production, use Postgres
    import psycopg2
    import sqlite3
    
    # Parse DATABASE_URL to handle special characters correctly
    parsed = urlparse(DATABASE_URL)
    
    # Build connection parameters safely
    # For serverless environments like Vercel, we need specific settings
    conn_params = {
        'host': parsed.hostname,
        'port': parsed.port or 5432,
        'database': parsed.path.lstrip('/'),
        'user': unquote(parsed.username) if parsed.username else None,
        'password': unquote(parsed.password) if parsed.password else None,
        'sslmode': 'require',
        # Serverless-friendly settings
        'connect_timeout': 10,  # Timeout after 10 seconds
        'keepalives': 1,
        'keepalives_idle': 30,
        'keepalives_interval': 10,
        'keepalives_count': 5,
    }
    
    # Detect if using connection pooler (recommended for Vercel)
    is_pooler = parsed.port == 6543 or '.pooler.' in (parsed.hostname or '')
    
    # Monkey patch sqlite3.connect to use Postgres instead
    original_connect = sqlite3.connect
    
    class PostgresCursor:
        """Wrapper around psycopg2 cursor that converts SQLite syntax to PostgreSQL"""
        def __init__(self, cursor):
            self._cursor = cursor
            self._last_description = None
            
        def _convert_query(self, query):
            """Convert SQLite syntax to PostgreSQL syntax"""
            if not query:
                return query
            
            # Convert placeholders: ? -> %s
            if '?' in query:
                query = query.replace('?', '%s')
            
            # Convert DDL (Data Definition Language) for CREATE TABLE
            if 'CREATE TABLE' in query.upper():
                # INTEGER PRIMARY KEY AUTOINCREMENT -> SERIAL PRIMARY KEY
                # Note: SERIAL is shorthand for INTEGER + GENERATED BY DEFAULT AS IDENTITY
                query = query.replace('INTEGER PRIMARY KEY AUTOINCREMENT', 'SERIAL PRIMARY KEY')
                query = query.replace('integer primary key autoincrement', 'SERIAL PRIMARY KEY')
                
                # DATETIME -> TIMESTAMP
                query = query.replace('DATETIME', 'TIMESTAMP')
                
                # CURRENT_TIMESTAMP is compatible with both, no change needed
                
                # TEXT is compatible, but PostgreSQL prefers VARCHAR for unique/indexed columns
                # We'll keep TEXT as it's more flexible and works fine in PostgreSQL
            
            return query
        
        def _make_row(self, values):
            """Convert tuple to a SQLite-compatible Row object"""
            if values is None or self._cursor.description is None:
                return values
            
            # Create a dict-like object that also supports index access
            class PostgresRow:
                def __init__(self, values, description):
                    self._values = values
                    self._description = description
                    # Create mapping of column names to values
                    self._mapping = {desc[0]: val for desc, val in zip(description, values)}
                
                def __getitem__(self, key):
                    if isinstance(key, int):
                        return self._values[key]
                    return self._mapping[key]
                
                def __iter__(self):
                    return iter(self._values)
                
                def keys(self):
                    return [desc[0] for desc in self._description]
                
                def values(self):
                    return list(self._values)
                
                def items(self):
                    return self._mapping.items()
                
                def __len__(self):
                    return len(self._values)
            
            return PostgresRow(values, self._cursor.description)
            
        def execute(self, query, params=None):
            # Convert SQLite syntax to PostgreSQL
            query = self._convert_query(query)
            result = self._cursor.execute(query, params)
            self._last_description = self._cursor.description
            return result
        
        def executemany(self, query, params_seq):
            query = self._convert_query(query)
            return self._cursor.executemany(query, params_seq)
        
        def fetchone(self):
            row = self._cursor.fetchone()
            return self._make_row(row) if row else None
        
        def fetchall(self):
            rows = self._cursor.fetchall()
            return [self._make_row(row) for row in rows]
        
        def fetchmany(self, size=None):
            rows = self._cursor.fetchmany(size)
            return [self._make_row(row) for row in rows]
        
        def __iter__(self):
            for row in self._cursor:
                yield self._make_row(row)
        
        def __getattr__(self, name):
            # Proxy all other attributes to the underlying cursor
            return getattr(self._cursor, name)
    
    class PostgresConnection:
        def __init__(self):
            try:
                self.conn = psycopg2.connect(**conn_params)
                self.row_factory = None
            except Exception as e:
                print(f"[database_patch] ❌ Failed to connect to Postgres: {e}")
                print(f"[database_patch] Host: {conn_params['host']}, Port: {conn_params['port']}")
                if not is_pooler:
                    print("[database_patch] ⚠️ Using direct connection (port 5432) - Consider using Supabase Connection Pooler (port 6543) for better Vercel compatibility")
                raise
            
        def cursor(self):
            # Return wrapped cursor that converts SQLite syntax to PostgreSQL
            # Use regular cursor (not RealDictCursor) for better compatibility
            pg_cursor = self.conn.cursor()
            return PostgresCursor(pg_cursor)
        
        def commit(self):
            self.conn.commit()
            
        def close(self):
            self.conn.close()
            
        def __enter__(self):
            return self
            
        def __exit__(self, *args):
            self.close()
    
    def postgres_connect(*args, **kwargs):
        """Replace SQLite connect with Postgres."""
        return PostgresConnection()
    
    # Monkey patch!
    import sqlite3
    sqlite3.connect = postgres_connect
    
    connection_type = "Pooler (IPv4)" if is_pooler else "Direct (may use IPv6)"
    print(f"[database_patch] ✅ Using Postgres (Supabase) - Host: {conn_params['host']}:{conn_params['port']} [{connection_type}]")
else:
    print("[database_patch] ℹ️  Using SQLite (local development)")

